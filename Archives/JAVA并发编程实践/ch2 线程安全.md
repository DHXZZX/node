# ch2 线程安全

编写线程安全的代码,本质上就是管理对状态(state)的访问,而且通常都是共享的,可变的状态

一个对象的状态就是它的数据,存储在状态变量(state variables)中. 对象的状态还包括了其他附属对象的域

所谓共享,是指一个变量被多个线程访问;所谓可变,是指变量的值在其生命周期内是可以改变的

无论何时,只要有多于一个的线程访问给定的状态变量,而且其中某个线程会写入该变量,此时必须使用同步来协调线程对该变量的访问.



## 什么是线程安全性

正确性意味着一个类与它的规约保持一致. 良好的规约定义了用于强制对象状态的不变约束(invariants)以及描述操作影响的后验条件(postconditions).

一个类是线程安全地,是指在被多个线程访问时,类可以保持预期的正确行为



对于线程安全类的实例进行顺序或并发的一系列操作,都不会导致实例处于无效状态

无状态对象永远是线程安全的



竞争条件

UnsafeCountingFactorizer中存在数个竞争条件, 导致其结果是不可靠的. 当计算的正确性依赖于运行时相关的时许或者多线程的交替时, 会产生竞争条件; 换句话说, 想要得到正确的答案, 要依赖于 "幸运"的时序, 最常见的一种竞争条件时 "检查再运行(check-then-act)" , 使用一个潜在的过期值作为决定下一步操作的依据.



竞争条件的诱因: 为获取期望的结果,需要依赖相关的事件的分时. 大多数竞争条件的特点---> 使用潜在的过期观察值来作决策或执行计算. 这种竞争条件被称为 **检查再运行(check-then-act)** : 你观察到一些事情为真(文件X不存在),然后(then)基于你的观察去执行一些动作(创建文件X); 但事实上,从观察到执行操作这段时间内,观察结果可能已经无效了(有人在此期间创建了文件X),从而引发了错误(非预期的异常,重写数据或者破环文件).



### 惰性初始化中的竞争条件

检查再运行的常见用法是惰性初始化(lazy initialization)

### 符合操作

相对于再同意状态的其他操作而言,必须是原子性或不可分割的. 为了避免竞争条件,必须组织其他线程访问我们正在修改的变量, 让我们可以确保: 当其他线程想要查看或修改一个状态时, 必须再我们的线程开始之前或完成之后, 而不能再操作过程中.

> 假设有操作A和B, 如果从执行A的线程的角度看, 当其他线程执行B时, 要么B全部执行完成, 要么一点都没有执行, 这样A和B互为原子操作. 一个原子操作是指: 该操作对于所有的操作, 包括它自己, 都满足前面描述的状态

## 锁

更新一个变量的时候,要在同一个原子操作中更新与之相关的其它几个变量

> 为了保护状态的一致性, 要在单一的原子操作中更新相互关联的状态变量

### 内部锁

synchronized 块

* 锁对象的引用
* 锁保护的代码块

synchronized方法是对跨越了整个方法体的synchronized快的简短描述

每个Java对象都可以隐式地扮演一个用于同步地锁地角色; 这些内置的锁配成为 **内部锁(intrinsic locks)**或**监视器锁(monitor locks)**. 执行线程进入synchronized块之前会自动获得锁; 而无论通过正常控制路径退出, 还是从块中抛出异常, 线程都在放弃对synchronized块地控制时自动释放锁. 获取内部锁地唯一途径是: 进入这个内部锁保护地同步块或方法.

内部锁在Java中扮演了**互斥锁(mutual exclusion lock, 也称为mutex)**地角色, 意味着至多只有一个线程可以拥有锁, 当线程A尝试请求一个被线程B占用地锁时, 线程A必须等待或阻塞,直到B释放锁. 

### 重进入(Reentrancy)

当一个线程请求其他线程已经占有地锁时,请求线程将被阻塞. 然而内部锁是可重入的, 因此线程在试图获取它自己占有的锁时, 请求会成功. 重进入意味着锁的请求基于"每线程(per-thread)", 而不是基于 "每调用(per-invocation)"的. 重进入的实现是通过为每个锁关联一个请求计数(acquisition count)和一个占有它的线程. 当计数为0时, 认为锁是未被占有的. 线程请求一个未被占有的锁时, JVM将记录锁的占有者, 并将计数置为1. 如果同一个线程再次请求这个锁, 计数将增加; 每次占用线程退出同步代码块, 计数器值递减. 直到计数器到达0, 锁被释放.

## 用锁来保护状态

## 活跃度与性能

决定synchronized块的大小需要权衡各种设计要求, 包括安全性,简单性和性能.

> 通常简单性与性能之间是相互牵制的. 实现一个同步策略时, 不要过早地为了性能而牺牲简单性(这是对安全性潜在的妥协)

当使用锁的时候,你应该清楚块中的代码的功能, 以及它的执行过程是否会很耗时. 无论是运算密集型的操作, 还是在执行一个可能存在潜在阻塞的操作, 如果线程长时间占有锁, 就会引起活跃度和性能风险的问题

