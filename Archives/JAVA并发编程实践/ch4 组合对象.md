# ch4 组合对象

## 设计线程安全的类

> 设计线程安全类的过程应该包括下面3个基本要素:
>
> * 确定对象状态是由那些变量构成的;
> * 确定限制状态变量的不变约束;
> * 制定一个管理并发访问对象状态的策略

同步策略(synchronization policy)定义了对象如何协调对其他状态的访问, 并且不会违反它的不变约束或后验条件. 它规定了如何把不可变性, 线程限制 和 锁限制结合起来, 从而维护线程的安全性, 还指明了那些所保护哪些变量. 

### 收集同步需求

维护类的线程安全意味着要确保在并发访问的情况下, 保护它的不变约束; 这需要对其状态进行判断. 对象于变量拥有一个**状态空间(state space)**: 即他们可能处于的窗台的范围. 状态空间越小, 越容易判断他们. 尽量使用final类型的域, 就可以简化我们对对象的可能状态进行分析(不可变对象是一种极限状态, 它只可能处于唯一的状态)

一个类的不变约束也可以约束多个状态变量. 这些变量必须服从下面的约束: 最小值边界应该小于或等于最大值边界. 这种多变量的不变约束需要原子性: 必须在单一的原子操作中获取或更行相互关联的变量.

### 状态依赖的操作

类的不变约束与方法的后验条件约束了对象合法的状态和合法状态转换. 某些对象方法也有基于状态的先验条件(preconditions). 若一个操作存在基于状态的先验条件, 则把它称为是状态依赖的(state-dependent).

在单线程化的程序中, 操作如果无法满足先验条件,必然失败,别无他选. 但是在并发程序中, 原本为假的先验条件可能会由于其他线程的活动而变为真. 并发程序中由这种可能: 持续等待,直到先验条件为真, 再继续处理操作.

### 状态所有权

## 实例限制

### Java监视器模式

线程限制原则的直接推论之一是**Java监视器模式(Java monitor pattern)**遵循Java监视器模式的对象封装了所有的可变状态,并由对象自己的内部锁保护.

## 委托线程安全

### 当委托无法胜任时

### 发布底层的状态变量



51.8

