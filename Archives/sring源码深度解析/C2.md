#### 注册解析后的BeanDefinition

```java
// Register the final decorated instance.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
```

```java
	/**
	 * Register the given bean definition with the given bean factory.
	 * @param definitionHolder the bean definition including name and aliases
	 * @param registry the bean factory to register with
	 * @throws BeanDefinitionStoreException if registration failed
	 */
	public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {
		//使用beanName做唯一标识注册
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
		//注册所有别名
		// Register aliases for bean name, if any.
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
```

解析出来的beanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中,而对于beanDefinition的注册分为两部分:通过beanName的注册以及通过别名的注册

* 通过beanName注册BeanDefinition

  > ```java
  > @Override
  > public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
  >       throws BeanDefinitionStoreException {
  > 
  >    Assert.hasText(beanName, "Bean name must not be empty");
  >    Assert.notNull(beanDefinition, "BeanDefinition must not be null");
  > 
  >    if (beanDefinition instanceof AbstractBeanDefinition) {
  >       try {
  >           //注册前的最后一次校验,这里的校验不同于之前的XML文件校验,
  >           //主要是对于AbstractBeanDefinition属性中的methodOverrides校验
  >           //校验methodOverrides是否于工厂方法并存或者methodOverrides对应的方法根本不存在
  >          ((AbstractBeanDefinition) beanDefinition).validate();
  >       }
  >       catch (BeanDefinitionValidationException ex) {
  >          throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
  >                "Validation of bean definition failed", ex);
  >       }
  >    }
  > 
  >    BeanDefinition oldBeanDefinition;
  > 
  >    oldBeanDefinition = this.beanDefinitionMap.get(beanName);
  >    if (oldBeanDefinition != null) {
  >       if (!isAllowBeanDefinitionOverriding()) {
  >          throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
  >                "Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
  >                "': There is already [" + oldBeanDefinition + "] bound.");
  >       }
  >       else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {
  >          // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
  >          if (this.logger.isWarnEnabled()) {
  >             this.logger.warn("Overriding user-defined bean definition for bean '" + beanName +
  >                   "' with a framework-generated bean definition: replacing [" +
  >                   oldBeanDefinition + "] with [" + beanDefinition + "]");
  >          }
  >       }
  >       else if (!beanDefinition.equals(oldBeanDefinition)) {
  >          if (this.logger.isInfoEnabled()) {
  >             this.logger.info("Overriding bean definition for bean '" + beanName +
  >                   "' with a different definition: replacing [" + oldBeanDefinition +
  >                   "] with [" + beanDefinition + "]");
  >          }
  >       }
  >       else {
  >          if (this.logger.isDebugEnabled()) {
  >             this.logger.debug("Overriding bean definition for bean '" + beanName +
  >                   "' with an equivalent definition: replacing [" + oldBeanDefinition +
  >                   "] with [" + beanDefinition + "]");
  >          }
  >       }
  >       this.beanDefinitionMap.put(beanName, beanDefinition);
  >    }
  >    else {
  >       if (hasBeanCreationStarted()) {
  >          // Cannot modify startup-time collection elements anymore (for stable iteration)
  >           //由于beanDefinitionMap是全局变量 这里一定会出现并发访问的情况
  >          synchronized (this.beanDefinitionMap) {
  >             this.beanDefinitionMap.put(beanName, beanDefinition);
  >             List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
  >             updatedDefinitions.addAll(this.beanDefinitionNames);
  >             updatedDefinitions.add(beanName);
  >             this.beanDefinitionNames = updatedDefinitions;
  >             if (this.manualSingletonNames.contains(beanName)) {
  >                Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);
  >                updatedSingletons.remove(beanName);
  >                this.manualSingletonNames = updatedSingletons;
  >             }
  >          }
  >       }
  >       else {
  >          // Still in startup registration phase
  >          this.beanDefinitionMap.put(beanName, beanDefinition);
  >          this.beanDefinitionNames.add(beanName);
  >          this.manualSingletonNames.remove(beanName);
  >       }
  >       this.frozenBeanDefinitionNames = null;
  >    }
  > 
  >    if (oldBeanDefinition != null || containsSingleton(beanName)) {
  >       resetBeanDefinition(beanName);
  >    }
  > }
  > ```

#### 通知监听器解析及注册完成

```java
	// Send registration event.
	getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
```



### alias标签的解析

```java
	/**
	 * Process the given alias element, registering the alias with the registry.
	 */
	protected void processAliasRegistration(Element ele) {
        //获取beanName
		String name = ele.getAttribute(NAME_ATTRIBUTE);
        //获取alias
		String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
		boolean valid = true;
		if (!StringUtils.hasText(name)) {
			getReaderContext().error("Name must not be empty", ele);
			valid = false;
		}
		if (!StringUtils.hasText(alias)) {
			getReaderContext().error("Alias must not be empty", ele);
			valid = false;
		}
		if (valid) {
			try {
                //注册alias
				getReaderContext().getRegistry().registerAlias(name, alias);
			}
			catch (Exception ex) {
				getReaderContext().error("Failed to register alias '" + alias +
						"' for bean with name '" + name + "'", ele, ex);
			}
            //别名注册后通知监听器做相应处理
			getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
		}
	}
```

## import标签的解析

```java
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
```

```java
	/**
	 * Parse an "import" element and load the bean definitions
	 * from the given resource into the bean factory.
	 */
	protected void importBeanDefinitionResource(Element ele) {
        //获取resource属性
		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
        //如果不存在resource,不做任何处理
		if (!StringUtils.hasText(location)) {
			getReaderContext().error("Resource location must not be empty", ele);
			return;
		}

		// Resolve system properties: e.g. "${user.dir}"
        //解析系统属性 "${user.dir}"
		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

		Set<Resource> actualResources = new LinkedHashSet<>(4);
		//判定location是绝对URI还是相对URI
		// Discover whether the location is an absolute or relative URI
		boolean absoluteLocation = false;
		try {
			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
		}
		catch (URISyntaxException ex) {
			// cannot convert to an URI, considering the location relative
			// unless it is the well-known Spring prefix "classpath*:"
		}

		// Absolute or relative?
        //如果是绝对RUI则直接根据地址加载对应的配置文件
		if (absoluteLocation) {
			try {
				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
				if (logger.isDebugEnabled()) {
					logger.debug("Imported " + importCount + " bean definitions from URL location [" + location + "]");
				}
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						"Failed to import bean definitions from URL location [" + location + "]", ele, ex);
			}
		}
		else {
			// No URL -> considering resource location as relative to the current file.
            //如果是相对地址,根据相对地址计算出绝对地址
			try {
				int importCount;
                //每个resource的createRelative方式实现都不一样,所以这里先使用子类的方法尝试解析
				Resource relativeResource = getReaderContext().getResource().createRelative(location);
				if (relativeResource.exists()) {
					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
					actualResources.add(relativeResource);
				}
				else {
                    //如果解析不成功则用默认的解析器ResourcePatternResolver进行解析
					String baseLocation = getReaderContext().getResource().getURL().toString();
					importCount = getReaderContext().getReader().loadBeanDefinitions(
							StringUtils.applyRelativePath(baseLocation, location), actualResources);
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Imported " + importCount + " bean definitions from relative location [" + location + "]");
				}
			}
			catch (IOException ex) {
				getReaderContext().error("Failed to resolve current resource location", ele, ex);
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error("Failed to import bean definitions from relative location [" + location + "]",
						ele, ex);
			}
		}
        //解析后进行监听器激活处理
		Resource[] actResArray = actualResources.toArray(new Resource[0]);
		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
	}
```

解析import标签的逻辑流程

* 获取resource属性表示的路径
* 解析路径中的系统属性,格式如"${user.dir}"
* 判定location是绝对路径还是相对路径
* 如果是绝对路径,递归调用bean的解析过程,进行另一次解析
* 如果是相对路径则计算出绝对路径,回归上一步
* 通知监听器,解析完成

## 嵌入式beans标签的解析

# 自定义标签的解析

```java
	/**
	 * Parse the elements at the root level in the document:
	 * "import", "alias", "bean".
	 * @param root the DOM root element of the document
	 */
	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
					}
					else {
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			delegate.parseCustomElement(root);
		}
	}
```

之前已经分析了`parseDefaultElement(ele, delegate)`是如何解析默认标签的,下面来分析`delegate.parseCustomElement(ele)`方法如何解析自定义标签

## 自定义标签的使用

扩展Spring自定义标签大致需要一下几个步骤

* 创建一个需要扩展的组件
* 定义一个XSD文件描述组件内容
* 创建一个文件,实现BeanDefinitionParser接口,用来解析XSD文件中的定义和组件定义
* 创建一个Handler文件扩展自NamespaceHandlerSupport,目的是将组件注册到Spring容器中
* 编写Spring.handlers和Spring.schemas文件

# bean的加载

```java
	@Override
	public <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException {
		return doGetBean(name, requiredType, null, false);
	}
```

```java
	/**
	 * Return an instance, which may be shared or independent, of the specified bean.
	 * @param name the name of the bean to retrieve
	 * @param requiredType the required type of the bean to retrieve
	 * @param args arguments to use when creating a bean instance using explicit arguments
	 * (only applied when creating a new instance as opposed to retrieving an existing one)
	 * @param typeCheckOnly whether the instance is obtained for a type check,
	 * not for actual use
	 * @return an instance of the bean
	 * @throws BeansException if the bean could not be created
	 */
	@SuppressWarnings("unchecked")
	protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
		//提取对应的beanName
		final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
			if (logger.isDebugEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.debug("Returning eagerly cached instance of singleton bean '" + beanName +
							"' that is not fully initialized yet - a consequence of a circular reference");
				}
				else {
					logger.debug("Returning cached instance of singleton bean '" + beanName + "'");
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
				// Not found -> check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else {
					// No args -> delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
			}

			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
						}
						registerDependentBean(dep, beanName);
						try {
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
						}
					}
				}

				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -> {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
					}
					try {
						Object scopedInstance = scope.get(beanName, () -> {
							beforePrototypeCreation(beanName);
							try {
								return createBean(beanName, mbd, args);
							}
							finally {
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								"Scope '" + scopeName + "' is not active for the current thread; consider " +
								"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null && !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			}
			catch (TypeMismatchException ex) {
				if (logger.isDebugEnabled()) {
					logger.debug("Failed to convert bean '" + name + "' to required type '" +
							ClassUtils.getQualifiedName(requiredType) + "'", ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
```

bean加载的逻辑

* 转换对应beanName

  > 由于传入的name可能是别名也可能是FactoryBean,所以需要进行解析
  >
  > * 去除FactoryBean的修饰符"&"也就是如果name="&aa",那么首先会去除& 使name="aa"
  > * 去除alias所表示的最终beanName,例如别名A指向名称为B的bean则返回B;若别名A指向别名B,别名B又指向名称C则会返回C

* 尝试从缓存中加载单例

  > 单例在Spring的同一个容器内只会被创建一次,后续再获取bean,就直接从单例缓存中获取.当然这里只是尝试加载,如果加载不成功还会再次从singletonFactories中加载.因为在创建单例bean的时候会存在依赖注入的情况,而在创建依赖的时候为了避免循环依赖,在Spring中创建bean的原则是不等bean创建完成就会创建Bean的ObjectFactory提早曝光加入到缓存中一旦下一个bean创建需要依赖上一个bean,则直接使用ObjectFactory

* bean的实例化

  > 如果从缓存中得到了bean的原始状态,则需要对bean进行实例化,缓存中记录的只是最原始的bean状态,并不一定是我们最终想要的bean.例如:我们需要对工厂bean进行处理,那么这里得到的其实就是工厂bean的初始状态,但我们真正需要的是工厂bean中定义的factory-method方法中返回的bean,而getObjectForBeanInstance就是完成这个工作

* 原型模式的依赖检查

  > 只有在单例情况下才会尝试解决循环依赖,如果存在A中有B的属性,B中有A的属性,当依赖注入的时候,就会判断循环依赖 即 `isPrototypeCurrentlyInCreation(beanName)`返回true

* 检测parentBeanFactory

  > 如果存在父容器,且在当前容器的beanDefinitionMap中没有该bean的名字,就会从父容器中getBean

* 将从各种配置中获取的GernericBeanDefinition转换为RootBeanDefinition

  > 在转换的时候如果父类bean不为空的话,合并父类的属性

* 寻找依赖

  > 先初始化当前bean依赖的其他bean

* 针对不同scope进行bean的创建

* 类型转换

  > 如果requiredType不为null并且该实例不是需要的类型

## FactoryBean的使用

一般情况下,Spring通过反射机制利用bean的class属性指定实现类来实例化bean.在某些情况下,实例化bean过程比较复杂,如果按照传统的方式,需要在<bean>中提供大量的配置信息,配置方式的灵活性是受限的,这时采用编码的方式可能会得到一个简单的方案.

Spring为此提供了一个FactoryBean的工厂类接口,用户可以通过实现该接口定制实例化bean的逻辑

```java
public interface FactoryBean<T> {

	/**
	 * Return an instance (possibly shared or independent) of the object
	 * managed by this factory.
	 * <p>As with a {@link BeanFactory}, this allows support for both the
	 * Singleton and Prototype design pattern.
	 * <p>If this FactoryBean is not fully initialized yet at the time of
	 * the call (for example because it is involved in a circular reference),
	 * throw a corresponding {@link FactoryBeanNotInitializedException}.
	 * <p>As of Spring 2.0, FactoryBeans are allowed to return {@code null}
	 * objects. The factory will consider this as normal value to be used; it
	 * will not throw a FactoryBeanNotInitializedException in this case anymore.
	 * FactoryBean implementations are encouraged to throw
	 * FactoryBeanNotInitializedException themselves now, as appropriate.
	 * @return an instance of the bean (can be {@code null})
	 * @throws Exception in case of creation errors
	 * @see FactoryBeanNotInitializedException
	 */
	@Nullable
	T getObject() throws Exception;

	/**
	 * Return the type of object that this FactoryBean creates,
	 * or {@code null} if not known in advance.
	 * <p>This allows one to check for specific types of beans without
	 * instantiating objects, for example on autowiring.
	 * <p>In the case of implementations that are creating a singleton object,
	 * this method should try to avoid singleton creation as far as possible;
	 * it should rather estimate the type in advance.
	 * For prototypes, returning a meaningful type here is advisable too.
	 * <p>This method can be called <i>before</i> this FactoryBean has
	 * been fully initialized. It must not rely on state created during
	 * initialization; of course, it can still use such state if available.
	 * <p><b>NOTE:</b> Autowiring will simply ignore FactoryBeans that return
	 * {@code null} here. Therefore it is highly recommended to implement
	 * this method properly, using the current state of the FactoryBean.
	 * @return the type of object that this FactoryBean creates,
	 * or {@code null} if not known at the time of the call
	 * @see ListableBeanFactory#getBeansOfType
	 */
	@Nullable
	Class<?> getObjectType();

	/**
	 * Is the object managed by this factory a singleton? That is,
	 * will {@link #getObject()} always return the same object
	 * (a reference that can be cached)?
	 * <p><b>NOTE:</b> If a FactoryBean indicates to hold a singleton object,
	 * the object returned from {@code getObject()} might get cached
	 * by the owning BeanFactory. Hence, do not return {@code true}
	 * unless the FactoryBean always exposes the same reference.
	 * <p>The singleton status of the FactoryBean itself will generally
	 * be provided by the owning BeanFactory; usually, it has to be
	 * defined as singleton there.
	 * <p><b>NOTE:</b> This method returning {@code false} does not
	 * necessarily indicate that returned objects are independent instances.
	 * An implementation of the extended {@link SmartFactoryBean} interface
	 * may explicitly indicate independent instances through its
	 * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
	 * implementations which do not implement this extended interface are
	 * simply assumed to always return independent instances if the
	 * {@code isSingleton()} implementation returns {@code false}.
	 * <p>The default implementation returns {@code true}, since a
	 * {@code FactoryBean} typically manages a singleton instance.
	 * @return whether the exposed object is a singleton
	 * @see #getObject()
	 * @see SmartFactoryBean#isPrototype()
	 */
	default boolean isSingleton() {
		return true;
	}

}
```



该接口中定义了3个方法

* 返回由FactoryBean创建的bean实例,如果isSingleton()返回true则该实例会放到Spring容器的单实例缓存池中

  ```java
  	@Nullable
  	T getObject() throws Exception;
  ```

* 返回由FactoryBean创建的bean实例的作用域是singleton还是prototype

  ```java
  	default boolean isSingleton() {
  		return true;
  	}
  ```

* 返回FactoryBean创建的bean的类型

  ```java
  	@Nullable
  	Class<?> getObjectType();
  ```

  

## 缓存中获取单例bean

`Object sharedInstance = getSingleton(beanName)`

```java
	@Override
	@Nullable
	public Object getSingleton(String beanName) {
		return getSingleton(beanName, true);
	}

	/**
	 * Return the (raw) singleton object registered under the given name.
	 * <p>Checks already instantiated singletons and also allows for an early
	 * reference to a currently created singleton (resolving a circular reference).
	 * @param beanName the name of the bean to look for
	 * @param allowEarlyReference whether early references should be created or not
	 * @return the registered singleton object, or {@code null} if none found
	 */
	@Nullable
	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		/**
		 * 从缓存中获取bean
		 */
		Object singletonObject = this.singletonObjects.get(beanName);
		/**
		 * 如果没有获取到
		 * 并判断是否需要立即初始化
		 */
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			/**
			 * 锁定全局变量,进行处理
			 */
			synchronized (this.singletonObjects) {
				/**
				 * 如果此bean正在加载,不处理
				 */
				singletonObject = this.earlySingletonObjects.get(beanName);
				/**
				 * 如果没有找到,并且允许早期引用
				 */
				if (singletonObject == null && allowEarlyReference) {
					//通过beanName获取对应singletonFactory
                    //当某些方法需要提前初始化的时候会调用addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories中
					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
                        //注意:earlySingletonObjects和singletonFactories互斥
                        //记录缓存
						this.earlySingletonObjects.put(beanName, singletonObject);
						//从singletonFactories中移除当前bean的factory
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
```

## 从bean的实例中获取对象

在getBean方法中,getObjectForBeanInstance是一个高频率使用的方法,无论是从缓存中获取bean还是根据不同的scope策略加载bean.总之,我们得到bean的实例后做的第一步就是调用这个方法来检测一下正确性,其实就是用于检测当前bean是否是FactoryBean类型的bean,如果是,就调用该bean的getObject方法将返回值作为结果

```java
	/**
	 * Get the object for the given bean instance, either the bean
	 * instance itself or its created object in case of a FactoryBean.
	 * @param beanInstance the shared bean instance
	 * @param name name that may include factory dereference prefix
	 * @param beanName the canonical bean name
	 * @param mbd the merged bean definition
	 * @return the object to expose for the bean
	 */
	protected Object getObjectForBeanInstance(
			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

		// Don't let calling code try to dereference the factory if the bean isn't a factory.
		if (BeanFactoryUtils.isFactoryDereference(name)) {
			if (beanInstance instanceof NullBean) {
				return beanInstance;
			}
			if (!(beanInstance instanceof FactoryBean)) {
				throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
			}
		}

		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
			return beanInstance;
		}

		Object object = null;
		if (mbd == null) {
			object = getCachedObjectForFactoryBean(beanName);
		}
		if (object == null) {
			// Return bean instance from factory.
			FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
			// Caches object obtained from FactoryBean if it is a singleton.
			if (mbd == null && containsBeanDefinition(beanName)) {
				mbd = getMergedLocalBeanDefinition(beanName);
			}
			boolean synthetic = (mbd != null && mbd.isSynthetic());
			object = getObjectFromFactoryBean(factory, beanName, !synthetic);
		}
		return object;
	}

```

`getObjectForBeanInstance`所做的工作

* 对FactoryBean正确性验证
* 对非FactoryBean不做任何处理
* 对bean进行转换
* 将从Factory中解析Bean的工作委托给`getObjectFromFactoryBean`

```java
	/**
	 * Obtain an object to expose from the given FactoryBean.
	 * @param factory the FactoryBean instance
	 * @param beanName the name of the bean
	 * @param shouldPostProcess whether the bean is subject to post-processing
	 * @return the object obtained from the FactoryBean
	 * @throws BeanCreationException if FactoryBean object creation failed
	 * @see org.springframework.beans.factory.FactoryBean#getObject()
	 */
	protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
		if (factory.isSingleton() && containsSingleton(beanName)) {
			synchronized (getSingletonMutex()) {
				Object object = this.factoryBeanObjectCache.get(beanName);
				if (object == null) {
					object = doGetObjectFromFactoryBean(factory, beanName);
					// Only post-process and store if not put there already during getObject() call above
					// (e.g. because of circular reference processing triggered by custom getBean calls)
					Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
					if (alreadyThere != null) {
						object = alreadyThere;
					}
					else {
						if (shouldPostProcess) {
							if (isSingletonCurrentlyInCreation(beanName)) {
								// Temporarily return non-post-processed object, not storing it yet..
								return object;
							}
							beforeSingletonCreation(beanName);
							try {
								object = postProcessObjectFromFactoryBean(object, beanName);
							}
							catch (Throwable ex) {
								throw new BeanCreationException(beanName,
										"Post-processing of FactoryBean's singleton object failed", ex);
							}
							finally {
								afterSingletonCreation(beanName);
							}
						}
						if (containsSingleton(beanName)) {
							this.factoryBeanObjectCache.put(beanName, object);
						}
					}
				}
				return object;
			}
		}
		else {
			Object object = doGetObjectFromFactoryBean(factory, beanName);
			if (shouldPostProcess) {
				try {
					object = postProcessObjectFromFactoryBean(object, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(beanName, "Post-processing of FactoryBean's object failed", ex);
				}
			}
			return object;
		}
	}

```

```java
	/**
	 * Obtain an object to expose from the given FactoryBean.
	 * @param factory the FactoryBean instance
	 * @param beanName the name of the bean
	 * @return the object obtained from the FactoryBean
	 * @throws BeanCreationException if FactoryBean object creation failed
	 * @see org.springframework.beans.factory.FactoryBean#getObject()
	 */
	private Object doGetObjectFromFactoryBean(final FactoryBean<?> factory, final String beanName)
			throws BeanCreationException {

		Object object;
		try {
			if (System.getSecurityManager() != null) {
				AccessControlContext acc = getAccessControlContext();
				try {
					object = AccessController.doPrivileged((PrivilegedExceptionAction<Object>) factory::getObject, acc);
				}
				catch (PrivilegedActionException pae) {
					throw pae.getException();
				}
			}
			else {
				object = factory.getObject();
			}
		}
		catch (FactoryBeanNotInitializedException ex) {
			throw new BeanCurrentlyInCreationException(beanName, ex.toString());
		}
		catch (Throwable ex) {
			throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex);
		}

		// Do not accept a null value for a FactoryBean that's not fully
		// initialized yet: Many FactoryBeans just return null then.
		if (object == null) {
			if (isSingletonCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(
						beanName, "FactoryBean which is currently in creation returned null from getObject");
			}
			object = new NullBean();
		}
		return object;
	}
```

Spring获取bean的规则中有一条:

尽可能保证所有bean初始化后都会调用注册的BeanPostProcessor的postProcessAfterInitialization方法进行处理

## 获取单例

如果从缓存中不存在已经加载的单例bean就需要从头开始bean的加载过程,Spring中使用getSingleton的重载方法实现bean的加载过程

```java
	/**
	 * Return the (raw) singleton object registered under the given name.
	 * <p>Checks already instantiated singletons and also allows for an early
	 * reference to a currently created singleton (resolving a circular reference).
	 * @param beanName the name of the bean to look for
	 * @param allowEarlyReference whether early references should be created or not
	 * @return the registered singleton object, or {@code null} if none found
	 */
	@Nullable
	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		Object singletonObject = this.singletonObjects.get(beanName);
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {
				singletonObject = this.earlySingletonObjects.get(beanName);
				if (singletonObject == null && allowEarlyReference) {
					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
```

## 准备创建bean

### 处理override属性

### 实例化的前置处理

```java
	/**
	 * Apply before-instantiation post-processors, resolving whether there is a
	 * before-instantiation shortcut for the specified bean.
	 * @param beanName the name of the bean
	 * @param mbd the bean definition for the bean
	 * @return the shortcut-determined bean instance, or {@code null} if none
	 */
	@Nullable
	protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
		Object bean = null;
		//如果尚未被解析
		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
			// Make sure bean class is actually resolved at this point.
			if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
				Class<?> targetType = determineTargetType(beanName, mbd);
				if (targetType != null) {
					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
					if (bean != null) {
						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
					}
				}
			}
			mbd.beforeInstantiationResolved = (bean != null);
		}
		return bean;
	}
```

#### 实例化前的后置处理器应用

bean实例化前调用,也就是将AbstractBeanDefinition转换为BeanWrapper前的处理,给子类一个修改BeanDefinition的机会,也就是说当程序经过这个方法后,bean可能已经不是我们认为的bean了,而是或许成为了一个经过处理的代理bean

```java
	/**
	 * Apply InstantiationAwareBeanPostProcessors to the specified bean definition
	 * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.
	 * <p>Any returned object will be used as the bean instead of actually instantiating
	 * the target bean. A {@code null} return value from the post-processor will
	 * result in the target bean being instantiated.
	 * @param beanClass the class of the bean to be instantiated
	 * @param beanName the name of the bean
	 * @return the bean object to use instead of a default instance of the target bean, or {@code null}
	 * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
	 */
	@Nullable
	protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}
```

## 循环依赖

### 什么是循环依赖

### Spring如何解决循环依赖

Spring容器循环依赖包括构造器循环依赖和setter循环依赖

#### 构造器循环依赖

通过构造器注入构成的循环依赖无法解决,抛出BeanCurrentlyInCreationException异常表示循环依赖

Spring容器将每个正在创建的bean标识符放在一个"当前创建bean池"中

```java
	/**
	 * The name of the currently created bean, for implicit dependency registration
	 * on getBean etc invocations triggered from a user-specified Supplier callback.
	 */
	private final NamedThreadLocal<String> currentlyCreatedBean = new NamedThreadLocal<>("Currently created bean");
```

标识符在bean创建过程中将一直保持在这个池中,因此如果在创建bean的过程中发现自己已经在currentlyCreatedBean缓存中就会抛出BeanCurrentlyInCreationException异常,而对于创建完毕的bean将从该缓存池中移除

#### setter循环依赖

对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但尚未完成其他步骤(如setter注入)的bean来完成的,而且只能解决singleton的bean循环依赖,通过提前暴露一个单例工厂方法,从而使其他bean能引用到该bean

#### prototype的依赖处理

对于prototype作用域的bean Spring容器如法完成依赖注入,因为Spring容器不进行缓存prototype作用域的bean,因此无法提前暴露一个创建中的bean

> 对于singleton作用域的bean可以通过`setAllowCircularReferences(false)`来禁用循环引用

## 创建bean

```java
	/**
	 * Actually create the specified bean. Pre-creation processing has already happened
	 * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
	 * <p>Differentiates between default bean instantiation, use of a
	 * factory method, and autowiring a constructor.
	 * @param beanName the name of the bean
	 * @param mbd the merged bean definition for the bean
	 * @param args explicit arguments to use for constructor or factory method invocation
	 * @return a new instance of the bean
	 * @throws BeanCreationException if the bean could not be created
	 * @see #instantiateBean
	 * @see #instantiateUsingFactoryMethod
	 * @see #autowireConstructor
	 */
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class<?> beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isDebugEnabled()) {
				logger.debug("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
		}

		return exposedObject;
	}

```

上述函数逻辑:

* 如果是单例需要首先清除缓存

* 实例化bean,将BeanDefinition转换为BeanWrapper

  * 如果存在工厂方法则使用工厂方法进行初始化
  * 一个类有多个构造函数,每个构造函数都有不同的参数,所以需要根据参数锁定构造函数并进行初始化
  * 如果既不存在工厂方法也不存在带参构造,则使用默认的构造函数进行bean的实例化

* MergedBeanDefinitionPostProcessor的应用

  > bean合并后的处理,Autowired注解正是通过此方法实现注入类型的预解析

* 依赖处理

* 属性填充,将所有属性填充至bean的实例中

*  循环依赖检查

  > Spring解决循环依赖只对单例有效,而对于prototype的bean,Spring没有好的解决办法,只能抛出异常,在这个步骤里会检测已经加载的bean是否已经出现了依赖循环,并判断是否需要抛出异常

* 注册DisposableBean

  > 如果配置了destroy-method,这里需要注册以便于在销毁的时候调用

* 完成创建并返回

### 5.7.1 创建bean的实例

createBeanInstance

```java
	/**
	 * Create a new instance for the specified bean, using an appropriate instantiation strategy:
	 * factory method, constructor autowiring, or simple instantiation.
	 * @param beanName the name of the bean
	 * @param mbd the bean definition for the bean
	 * @param args explicit arguments to use for constructor or factory method invocation
	 * @return a BeanWrapper for the new instance
	 * @see #obtainFromSupplier
	 * @see #instantiateUsingFactoryMethod
	 * @see #autowireConstructor
	 * @see #instantiateBean
	 */
	protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
		// Make sure bean class is actually resolved at this point.
		Class<?> beanClass = resolveBeanClass(mbd, beanName);

		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					"Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
		}

		Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
		if (instanceSupplier != null) {
			return obtainFromSupplier(instanceSupplier, beanName);
		}

		if (mbd.getFactoryMethodName() != null)  {
			return instantiateUsingFactoryMethod(beanName, mbd, args);
		}

		// Shortcut when re-creating the same bean...
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
					resolved = true;
					autowireNecessary = mbd.constructorArgumentsResolved;
				}
			}
		}
		if (resolved) {
			if (autowireNecessary) {
				return autowireConstructor(beanName, mbd, null, null);
			}
			else {
				return instantiateBean(beanName, mbd);
			}
		}

		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
			return autowireConstructor(beanName, mbd, ctors, args);
		}

		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
	}

```

上述代码逻辑:

* 如果在RootBeanDefinition中存在factoryMethodName属性,或者说在配置文件中配置了factory-method,那么Spring会尝试使用`instantiateUsingFactoryMethod(beanName,mbd,args)`方法根据RootBeanDefinition中的配置生成bean的实例

* 解析构造函数并进行构造函数的实例化.因为一个bean对应的类中可能会有多个构造函数,而每个构造函数的参数不同,Spring会根据参数列表判断最终使用哪个构造函数进行实例化.但是,判断的过程是一个比较消耗性能的步骤,所以采用缓存机制,如果已经解析过则不需要重复解析而是直接从RootBeanDefinition中的属性ResolvedConstructorOrFactoryMethod缓存中去取值,否则需要再次解析,并将解析的结果再次存入缓存

  * autowireConstructor

    > 对于实例的创建Spring中分成了两种情况,一种是通用的实例化,另一种是带有参数的实例化
    >
    > ```java
    > 	/**
    > 	 * "autowire constructor" (with constructor arguments by type) behavior.
    > 	 * Also applied if explicit constructor argument values are specified,
    > 	 * matching all remaining arguments with beans from the bean factory.
    > 	 * <p>This corresponds to constructor injection: In this mode, a Spring
    > 	 * bean factory is able to host components that expect constructor-based
    > 	 * dependency resolution.
    > 	 * @param beanName the name of the bean
    > 	 * @param mbd the merged bean definition for the bean
    > 	 * @param chosenCtors chosen candidate constructors (or {@code null} if none)
    > 	 * @param explicitArgs argument values passed in programmatically via the getBean method,
    > 	 * or {@code null} if none (-> use constructor argument values from bean definition)
    > 	 * @return a BeanWrapper for the new instance
    > 	 */
    > 	public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,
    > 			@Nullable Constructor<?>[] chosenCtors, @Nullable final Object[] explicitArgs) {
    > 
    > 		BeanWrapperImpl bw = new BeanWrapperImpl();
    > 		this.beanFactory.initBeanWrapper(bw);
    > 
    > 		Constructor<?> constructorToUse = null;
    > 		ArgumentsHolder argsHolderToUse = null;
    > 		Object[] argsToUse = null;
    > 
    > 		if (explicitArgs != null) {
    > 			argsToUse = explicitArgs;
    > 		}
    > 		else {
    > 			Object[] argsToResolve = null;
    > 			synchronized (mbd.constructorArgumentLock) {
    > 				constructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;
    > 				if (constructorToUse != null && mbd.constructorArgumentsResolved) {
    > 					// Found a cached constructor...
    > 					argsToUse = mbd.resolvedConstructorArguments;
    > 					if (argsToUse == null) {
    > 						argsToResolve = mbd.preparedConstructorArguments;
    > 					}
    > 				}
    > 			}
    > 			if (argsToResolve != null) {
    > 				argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
    > 			}
    > 		}
    > 
    > 		if (constructorToUse == null) {
    > 			// Need to resolve the constructor.
    > 			boolean autowiring = (chosenCtors != null ||
    > 					mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
    > 			ConstructorArgumentValues resolvedValues = null;
    > 
    > 			int minNrOfArgs;
    > 			if (explicitArgs != null) {
    > 				minNrOfArgs = explicitArgs.length;
    > 			}
    > 			else {
    > 				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
    > 				resolvedValues = new ConstructorArgumentValues();
    > 				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
    > 			}
    > 
    > 			// Take specified constructors, if any.
    > 			Constructor<?>[] candidates = chosenCtors;
    > 			if (candidates == null) {
    > 				Class<?> beanClass = mbd.getBeanClass();
    > 				try {
    > 					candidates = (mbd.isNonPublicAccessAllowed() ?
    > 							beanClass.getDeclaredConstructors() : beanClass.getConstructors());
    > 				}
    > 				catch (Throwable ex) {
    > 					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    > 							"Resolution of declared constructors on bean Class [" + beanClass.getName() +
    > 							"] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);
    > 				}
    > 			}
    > 			AutowireUtils.sortConstructors(candidates);
    > 			int minTypeDiffWeight = Integer.MAX_VALUE;
    > 			Set<Constructor<?>> ambiguousConstructors = null;
    > 			LinkedList<UnsatisfiedDependencyException> causes = null;
    > 
    > 			for (Constructor<?> candidate : candidates) {
    > 				Class<?>[] paramTypes = candidate.getParameterTypes();
    > 
    > 				if (constructorToUse != null && argsToUse.length > paramTypes.length) {
    > 					// Already found greedy constructor that can be satisfied ->
    > 					// do not look any further, there are only less greedy constructors left.
    > 					break;
    > 				}
    > 				if (paramTypes.length < minNrOfArgs) {
    > 					continue;
    > 				}
    > 
    > 				ArgumentsHolder argsHolder;
    > 				if (resolvedValues != null) {
    > 					try {
    > 						String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
    > 						if (paramNames == null) {
    > 							ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
    > 							if (pnd != null) {
    > 								paramNames = pnd.getParameterNames(candidate);
    > 							}
    > 						}
    > 						argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
    > 								getUserDeclaredConstructor(candidate), autowiring);
    > 					}
    > 					catch (UnsatisfiedDependencyException ex) {
    > 						if (logger.isTraceEnabled()) {
    > 							logger.trace("Ignoring constructor [" + candidate + "] of bean '" + beanName + "': " + ex);
    > 						}
    > 						// Swallow and try next constructor.
    > 						if (causes == null) {
    > 							causes = new LinkedList<>();
    > 						}
    > 						causes.add(ex);
    > 						continue;
    > 					}
    > 				}
    > 				else {
    > 					// Explicit arguments given -> arguments length must match exactly.
    > 					if (paramTypes.length != explicitArgs.length) {
    > 						continue;
    > 					}
    > 					argsHolder = new ArgumentsHolder(explicitArgs);
    > 				}
    > 
    > 				int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
    > 						argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
    > 				// Choose this constructor if it represents the closest match.
    > 				if (typeDiffWeight < minTypeDiffWeight) {
    > 					constructorToUse = candidate;
    > 					argsHolderToUse = argsHolder;
    > 					argsToUse = argsHolder.arguments;
    > 					minTypeDiffWeight = typeDiffWeight;
    > 					ambiguousConstructors = null;
    > 				}
    > 				else if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {
    > 					if (ambiguousConstructors == null) {
    > 						ambiguousConstructors = new LinkedHashSet<>();
    > 						ambiguousConstructors.add(constructorToUse);
    > 					}
    > 					ambiguousConstructors.add(candidate);
    > 				}
    > 			}
    > 
    > 			if (constructorToUse == null) {
    > 				if (causes != null) {
    > 					UnsatisfiedDependencyException ex = causes.removeLast();
    > 					for (Exception cause : causes) {
    > 						this.beanFactory.onSuppressedException(cause);
    > 					}
    > 					throw ex;
    > 				}
    > 				throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    > 						"Could not resolve matching constructor " +
    > 						"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");
    > 			}
    > 			else if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {
    > 				throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    > 						"Ambiguous constructor matches found in bean '" + beanName + "' " +
    > 						"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " +
    > 						ambiguousConstructors);
    > 			}
    > 
    > 			if (explicitArgs == null) {
    > 				argsHolderToUse.storeCache(mbd, constructorToUse);
    > 			}
    > 		}
    > 
    > 		try {
    > 			final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();
    > 			Object beanInstance;
    > 
    > 			if (System.getSecurityManager() != null) {
    > 				final Constructor<?> ctorToUse = constructorToUse;
    > 				final Object[] argumentsToUse = argsToUse;
    > 				beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
    > 						strategy.instantiate(mbd, beanName, beanFactory, ctorToUse, argumentsToUse),
    > 						beanFactory.getAccessControlContext());
    > 			}
    > 			else {
    > 				beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
    > 			}
    > 
    > 			bw.setBeanInstance(beanInstance);
    > 			return bw;
    > 		}
    > 		catch (Throwable ex) {
    > 			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    > 					"Bean instantiation via constructor failed", ex);
    > 		}
    > 	}
    > ```
    >
    > 该函数的大致逻辑:
    >
    > * 构造函数参数确定
    >
    >   * 根据explicitArgs参数判断
    >
    >     > 如果传入的参数explicitArgs不为空,那么可以直接确定参数,因为explicitArgs实在调用Bean的时候用户指定的,在BeanFactory类中存在该方法`public Object getBean(String name, Object... args) throws BeansException` 在获取bean的时候,用户不但可以指定bean的名称,还可以指定bean所对应类的构造函数或者工厂方法的方法参数,主要用于静态工厂方法的调用,而这里是需要给定完全匹配的参数的,所以,便可以判断,如果传入参数explicitArgs不为空,则能据此判断对应的构造函数
    >
    >   * 缓存中取
    >
    >     > 由于构造函数在上次已经存入缓存中,因此可以直接取出,但缓存中的参数可能是未解析的原始参数也可能是已经解析的最终类型的参数,因此,即使从缓存中取得了参数,也需要经过类型转换器的过滤以确保参数类型于对应的构造函数参数类型完全对应
    >
    >   * 配置文件获取
    >
    >     > 如果不能根据传入的参数explicitArgs对应构造函数的参数也无法在缓存中得到相关信息,那么就需要开始新一轮的分析了
    >     >
    >     > Spring中配置文件中的信息经过转换都会存入BeanDefinition中,也就是参数mbd中通过调用`mbd.getConstructorArgumentValues()`来获取配置的构造函数信息.有了配置信息便可以获取对应的参数值信息了,该获取方法委托给了`resolveConstructorArguments`方法
    >     >
    >     > ```java
    >     > private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
    >     > 			ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues)
    >     > ```
    >
    > * 构造函数的确定
    >
    >   经过第一步后已经确定了构造函数的参数,接卸来需要根据构造函数参数列表来锁定对应的构造函数,首先对构造函数进行排序,再判断
    >
    >   由于再配置文件中并不是唯一限定用参数位置索引的方式创建,同样还支持指定参数名称进行参数值的这顶如:<constructor-arg name = "aa">那么这种情况下需要首先确定构造函数中的参数名称
    >
    >   获取参数名称可以有两种方式,一种是根据注解的方式来直接获取,另一种是使用Spring中提供的工具类ParameterNameDiscoverer来获取.构造函数,参数名称,参数类型,参数值都确定后就可以锁定构造函数以及转换对应的参数类型了
    >
    > * 根据确定的构造函数转换对应的参数类型
    >
    >   主要是使用Spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换
    >
    > * 构造函数不确定性的验证
    >
    >   当然,有时候即使构造函数,参数名称,参数类型,参数值都确定后也不一定会直接锁定构造函数,不同构造函数的参数为父子关系,所以Spring再最后又做了一次验证
    >
    > * 根据实例化策略以及得到的构造函数以及构造函数参数实例化bean

  * instantiateBean

    `instantiateBean(beanName, mbd)`

    ```java
    	/**
    	 * Instantiate the given bean using its default constructor.
    	 * @param beanName the name of the bean
    	 * @param mbd the bean definition for the bean
    	 * @return a BeanWrapper for the new instance
    	 */
    	protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    		try {
    			Object beanInstance;
    			final BeanFactory parent = this;
    			if (System.getSecurityManager() != null) {
    				beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
    						getInstantiationStrategy().instantiate(mbd, beanName, parent),
    						getAccessControlContext());
    			}
    			else {
    				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
    			}
    			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
    			initBeanWrapper(bw);
    			return bw;
    		}
    		catch (Throwable ex) {
    			throw new BeanCreationException(
    					mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
    		}
    	}
    ```

  * 实力话策略

    ```java
    	@Override
    	public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
    		// Don't override the class with CGLIB if no overrides.
    		if (!bd.hasMethodOverrides()) {
    			Constructor<?> constructorToUse;
    			synchronized (bd.constructorArgumentLock) {
    				constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
    				if (constructorToUse == null) {
    					final Class<?> clazz = bd.getBeanClass();
    					if (clazz.isInterface()) {
    						throw new BeanInstantiationException(clazz, "Specified class is an interface");
    					}
    					try {
    						if (System.getSecurityManager() != null) {
    							constructorToUse = AccessController.doPrivileged(
    									(PrivilegedExceptionAction<Constructor<?>>) clazz::getDeclaredConstructor);
    						}
    						else {
    							constructorToUse =	clazz.getDeclaredConstructor();
    						}
    						bd.resolvedConstructorOrFactoryMethod = constructorToUse;
    					}
    					catch (Throwable ex) {
    						throw new BeanInstantiationException(clazz, "No default constructor found", ex);
    					}
    				}
    			}
    			return BeanUtils.instantiateClass(constructorToUse);
    		}
    		else {
    			// Must generate CGLIB subclass.
    			return instantiateWithMethodInjection(bd, beanName, owner);
    		}
    	}
    ```

    上述逻辑中,首先判断如果beanDefinition.getMethodOverrides()为空也就是用户没有使用replace或lookup的配置方法,那么直接使用泛着的方式,但如果使用了这两个特性,则需要使用动态代理的方式将包含这两个特性对应的逻辑的拦截增强器设置进去,这样才可以保证在调用方法的时候会被相应的增强,返回值为包含拦截器的代理实例

    ```java
    		/**
    		 * Create a new instance of a dynamically generated subclass implementing the
    		 * required lookups.
    		 * @param ctor constructor to use. If this is {@code null}, use the
    		 * no-arg constructor (no parameterization, or Setter Injection)
    		 * @param args arguments to use for the constructor.
    		 * Ignored if the {@code ctor} parameter is {@code null}.
    		 * @return new instance of the dynamically generated subclass
    		 */
    		public Object instantiate(@Nullable Constructor<?> ctor, @Nullable Object... args) {
    			Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
    			Object instance;
    			if (ctor == null) {
    				instance = BeanUtils.instantiateClass(subclass);
    			}
    			else {
    				try {
    					Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
    					instance = enhancedSubclassConstructor.newInstance(args);
    				}
    				catch (Exception ex) {
    					throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
    							"Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
    				}
    			}
    			// SPR-10785: set callbacks directly on the instance instead of in the
    			// enhanced class (via the Enhancer) in order to avoid memory leaks.
    			Factory factory = (Factory) instance;
    			factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
    					new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
    					new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
    			return instance;
    		}
    ```

    ```java
    		/**
    		 * Create an enhanced subclass of the bean class for the provided bean
    		 * definition, using CGLIB.
    		 */
    		private Class<?> createEnhancedSubclass(RootBeanDefinition beanDefinition) {
    			Enhancer enhancer = new Enhancer();
    			enhancer.setSuperclass(beanDefinition.getBeanClass());
    			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    			if (this.owner instanceof ConfigurableBeanFactory) {
    				ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader();
    				enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));
    			}
    			enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));
    			enhancer.setCallbackTypes(CALLBACK_TYPES);
    			return enhancer.createClass();
    		}
    	}
    ```

### 5.7.2 记录创建bean的ObjectFactory

Spring的依赖解决办法

* earlySingletonExposure

* mbd.isSingleton()

* this.allowCircularReferences:可以通过因编码方式设置

* isSingletonCurrentlyInCreation(beanName)

  > 该bean是否正在创建中.在Spring中,有一个专门的属性DefaultSingletonBeanRegistry的singletonsCurrentlyInCreation来记载bean的加载状态,在bean开始创建前会将beanName记录在属性中,在bean创建结束后会将beanName从属性中移除,不同的scope的记录位置不同,singleton下记录属性的函数在`public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) `中

经过上述逻辑,我们了解了变量earlySingletonExposure是否是单例,是否允许循环依赖,是否对应的bean正在创建的综合条件.当这三个条件都满足时,会执行addSingletonFactory操作

在B中创建依赖A时通过ObjectFactory提供的实力话方法来中断A中的属性填充,使B中持有的A仅仅是刚刚初始化并没有填充任何属性的A,而这正在初始化A的步骤还是在最开始创建A的时候进行的,但是因为A与B中的A所表示的属性地址都是一样的,所以在A中创建好的属性填充自然可以通过B中的A获取,这样就解决了循环依赖的问题了

### 了解FactoryBean

### 5.7.3 属性注入

```java
	/**
	 * Populate the bean instance in the given BeanWrapper with the property values
	 * from the bean definition.
	 * @param beanName the name of the bean
	 * @param mbd the bean definition for the bean
	 * @param bw BeanWrapper with bean instance
	 */
	protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		if (bw == null) {
			if (mbd.hasPropertyValues()) {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
			}
			else {
				// Skip property population phase for null instance.
				return;
			}
		}

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		boolean continueWithPropertyPopulation = true;

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						continueWithPropertyPopulation = false;
						break;
					}
				}
			}
		}

		if (!continueWithPropertyPopulation) {
			return;
		}

		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

			// Add property values based on autowire by name if applicable.
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}

			// Add property values based on autowire by type if applicable.
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}

			pvs = newPvs;
		}

		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

		if (hasInstAwareBpps || needsDepCheck) {
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			if (hasInstAwareBpps) {
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvs == null) {
							return;
						}
					}
				}
			}
			if (needsDepCheck) {
				checkDependencies(beanName, mbd, filteredPds, pvs);
			}
		}

		if (pvs != null) {
			applyPropertyValues(beanName, mbd, bw, pvs);
		}
	}
```

上述逻辑:

* InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用,此函数可以空指程序是否继续进行属性填充
* 根据注入类型,提取依赖的bean,并统一存入PropertyValues中
* 应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法,对属性获取完毕填充前对属性的再次处理,典型应用是RequiredAnnotationBeanPostProcessor类中对属性的验证
* 将所有PropertyValues中的属性填充至BeanWrapper中

#### autowireByName

```java
	/**
	 * Fill in any missing property values with references to
	 * other beans in this factory if autowire is set to "byName".
	 * @param beanName the name of the bean we're wiring up.
	 * Useful for debugging messages; not used functionally.
	 * @param mbd bean definition to update through autowiring
	 * @param bw BeanWrapper from which we can obtain information about the bean
	 * @param pvs the PropertyValues to register wired objects with
	 */
	protected void autowireByName(
			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
		for (String propertyName : propertyNames) {
			if (containsBean(propertyName)) {
				Object bean = getBean(propertyName);
				pvs.add(propertyName, bean);
				registerDependentBean(propertyName, beanName);
				if (logger.isDebugEnabled()) {
					logger.debug("Added autowiring by name from bean name '" + beanName +
							"' via property '" + propertyName + "' to bean named '" + propertyName + "'");
				}
			}
			else {
				if (logger.isTraceEnabled()) {
					logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +
							"' by name: no matching bean found");
				}
			}
		}
	}

```

在传入的参数pvs中找出已经加载的bean,递归实例化,进而加入到pvs中

#### autowireByType

```java
	/**
	 * Abstract method defining "autowire by type" (bean properties by type) behavior.
	 * <p>This is like PicoContainer default, in which there must be exactly one bean
	 * of the property type in the bean factory. This makes bean factories simple to
	 * configure for small namespaces, but doesn't work as well as standard Spring
	 * behavior for bigger applications.
	 * @param beanName the name of the bean to autowire by type
	 * @param mbd the merged bean definition to update through autowiring
	 * @param bw BeanWrapper from which we can obtain information about the bean
	 * @param pvs the PropertyValues to register wired objects with
	 */
	protected void autowireByType(
			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

		TypeConverter converter = getCustomTypeConverter();
		if (converter == null) {
			converter = bw;
		}

		Set<String> autowiredBeanNames = new LinkedHashSet<>(4);
		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
		for (String propertyName : propertyNames) {
			try {
				PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
				// Don't try autowiring by type for type Object: never makes sense,
				// even if it technically is a unsatisfied, non-simple property.
				if (Object.class != pd.getPropertyType()) {
					MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
					// Do not allow eager init for type matching in case of a prioritized post-processor.
					boolean eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance());
					DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
					Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
					if (autowiredArgument != null) {
						pvs.add(propertyName, autowiredArgument);
					}
					for (String autowiredBeanName : autowiredBeanNames) {
						registerDependentBean(autowiredBeanName, beanName);
						if (logger.isDebugEnabled()) {
							logger.debug("Autowiring by type from bean name '" + beanName + "' via property '" +
									propertyName + "' to bean named '" + autowiredBeanName + "'");
						}
					}
					autowiredBeanNames.clear();
				}
			}
			catch (BeansException ex) {
				throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
			}
		}
	}
```

doResolveDependency通用处理逻辑

```java
	@Nullable
	public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
		try {
			Object shortcut = descriptor.resolveShortcut(this);
			if (shortcut != null) {
				return shortcut;
			}

			Class<?> type = descriptor.getDependencyType();
			Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
			if (value != null) {
				if (value instanceof String) {
					String strVal = resolveEmbeddedValue((String) value);
					BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
					value = evaluateBeanDefinitionString(strVal, bd);
				}
				TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
				return (descriptor.getField() != null ?
						converter.convertIfNecessary(value, type, descriptor.getField()) :
						converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
			}

			Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
			if (multipleBeans != null) {
				return multipleBeans;
			}

			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
			if (matchingBeans.isEmpty()) {
				if (isRequired(descriptor)) {
					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
				}
				return null;
			}

			String autowiredBeanName;
			Object instanceCandidate;

			if (matchingBeans.size() > 1) {
				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
				if (autowiredBeanName == null) {
					if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
						return descriptor.resolveNotUnique(type, matchingBeans);
					}
					else {
						// In case of an optional Collection/Map, silently ignore a non-unique case:
						// possibly it was meant to be an empty collection of multiple regular beans
						// (before 4.3 in particular when we didn't even look for collection beans).
						return null;
					}
				}
				instanceCandidate = matchingBeans.get(autowiredBeanName);
			}
			else {
				// We have exactly one match.
				Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
				autowiredBeanName = entry.getKey();
				instanceCandidate = entry.getValue();
			}

			if (autowiredBeanNames != null) {
				autowiredBeanNames.add(autowiredBeanName);
			}
			if (instanceCandidate instanceof Class) {
				instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
			}
			Object result = instanceCandidate;
			if (result instanceof NullBean) {
				if (isRequired(descriptor)) {
					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
				}
				result = null;
			}
			if (!ClassUtils.isAssignableValue(type, result)) {
				throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
			}
			return result;
		}
		finally {
			ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
		}
	}
```

#### applyPropertyValues

```java
	/**
	 * Apply the given property values, resolving any runtime references
	 * to other beans in this bean factory. Must use deep copy, so we
	 * don't permanently modify this property.
	 * @param beanName the bean name passed for better exception information
	 * @param mbd the merged bean definition
	 * @param bw the BeanWrapper wrapping the target object
	 * @param pvs the new property values
	 */
	protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
		if (pvs.isEmpty()) {
			return;
		}

		if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {
			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
		}

		MutablePropertyValues mpvs = null;
		List<PropertyValue> original;

		if (pvs instanceof MutablePropertyValues) {
			mpvs = (MutablePropertyValues) pvs;
			if (mpvs.isConverted()) {
				// Shortcut: use the pre-converted values as-is.
				try {
					bw.setPropertyValues(mpvs);
					return;
				}
				catch (BeansException ex) {
					throw new BeanCreationException(
							mbd.getResourceDescription(), beanName, "Error setting property values", ex);
				}
			}
			original = mpvs.getPropertyValueList();
		}
		else {
			original = Arrays.asList(pvs.getPropertyValues());
		}

		TypeConverter converter = getCustomTypeConverter();
		if (converter == null) {
			converter = bw;
		}
		BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

		// Create a deep copy, resolving any references for values.
		List<PropertyValue> deepCopy = new ArrayList<>(original.size());
		boolean resolveNecessary = false;
		for (PropertyValue pv : original) {
			if (pv.isConverted()) {
				deepCopy.add(pv);
			}
			else {
				String propertyName = pv.getName();
				Object originalValue = pv.getValue();
				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
				Object convertedValue = resolvedValue;
				boolean convertible = bw.isWritableProperty(propertyName) &&
						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
				if (convertible) {
					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
				}
				// Possibly store converted value in merged bean definition,
				// in order to avoid re-conversion for every created bean instance.
				if (resolvedValue == originalValue) {
					if (convertible) {
						pv.setConvertedValue(convertedValue);
					}
					deepCopy.add(pv);
				}
				else if (convertible && originalValue instanceof TypedStringValue &&
						!((TypedStringValue) originalValue).isDynamic() &&
						!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
					pv.setConvertedValue(convertedValue);
					deepCopy.add(pv);
				}
				else {
					resolveNecessary = true;
					deepCopy.add(new PropertyValue(pv, convertedValue));
				}
			}
		}
		if (mpvs != null && !resolveNecessary) {
			mpvs.setConverted();
		}

		// Set our (possibly massaged) deep copy.
		try {
			bw.setPropertyValues(new MutablePropertyValues(deepCopy));
		}
		catch (BeansException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Error setting property values", ex);
		}
	}
```

#### 初始化bean

```java
	/**
	 * Initialize the given bean instance, applying factory callbacks
	 * as well as init methods and bean post processors.
	 * <p>Called from {@link #createBean} for traditionally defined beans,
	 * and from {@link #initializeBean} for existing bean instances.
	 * @param beanName the bean name in the factory (for debugging purposes)
	 * @param bean the new bean instance we may need to initialize
	 * @param mbd the bean definition that the bean was created with
	 * (can also be {@code null}, if given an existing bean instance)
	 * @return the initialized bean instance (potentially wrapped)
	 * @see BeanNameAware
	 * @see BeanClassLoaderAware
	 * @see BeanFactoryAware
	 * @see #applyBeanPostProcessorsBeforeInitialization
	 * @see #invokeInitMethods
	 * @see #applyBeanPostProcessorsAfterInitialization
	 */
	protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			invokeAwareMethods(beanName, bean);
		}

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, "Invocation of init method failed", ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
	}
```

##### 激活Aware方法

Spring中提供一些Aware相关接口,比如BeanFactoryAware,ApplicationContextAware,ResourceLoaderAware,ServletContextAware等

![Aware](C:\Users\10066610\Documents\Note\sring源码深度解析\imgs\awares.png)

实现这些Aware接口的bean在被初始化后,可以取得一些相对应的资源.

```java
	private void invokeAwareMethods(final String beanName, final Object bean) {
		if (bean instanceof Aware) {
			if (bean instanceof BeanNameAware) {
				((BeanNameAware) bean).setBeanName(beanName);
			}
			if (bean instanceof BeanClassLoaderAware) {
				ClassLoader bcl = getBeanClassLoader();
				if (bcl != null) {
					((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
				}
			}
			if (bean instanceof BeanFactoryAware) {
				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
			}
		}
	}
```

##### 处理器的应用

##### 激活自定义的init方法

客户定制的初始化方法除了使用init-method外,还有使用自定义的bean实现InitializingBean接口,并在afterPropertiesSet中实现自己的初始化业务逻辑

init-method与afterPropertiesSet都是在初始化bean时执行,执行顺序时afterPropertiesSet先执行,而init-method后执行

在invokeInitMethods方法中就实现了这两个步骤的初始化方法调用

```java
	/**
	 * Give a bean a chance to react now all its properties are set,
	 * and a chance to know about its owning bean factory (this object).
	 * This means checking whether the bean implements InitializingBean or defines
	 * a custom init method, and invoking the necessary callback(s) if it does.
	 * @param beanName the bean name in the factory (for debugging purposes)
	 * @param bean the new bean instance we may need to initialize
	 * @param mbd the merged bean definition that the bean was created with
	 * (can also be {@code null}, if given an existing bean instance)
	 * @throws Throwable if thrown by init methods or by the invocation process
	 * @see #invokeCustomInitMethod
	 */
	protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
			throws Throwable {

		boolean isInitializingBean = (bean instanceof InitializingBean);
		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
			if (logger.isDebugEnabled()) {
				logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
			}
			if (System.getSecurityManager() != null) {
				try {
					AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
						((InitializingBean) bean).afterPropertiesSet();
						return null;
					}, getAccessControlContext());
				}
				catch (PrivilegedActionException pae) {
					throw pae.getException();
				}
			}
			else {
				((InitializingBean) bean).afterPropertiesSet();
			}
		}

		if (mbd != null && bean.getClass() != NullBean.class) {
			String initMethodName = mbd.getInitMethodName();
			if (StringUtils.hasLength(initMethodName) &&
					!(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
					!mbd.isExternallyManagedInitMethod(initMethodName)) {
				invokeCustomInitMethod(beanName, bean, mbd);
			}
		}
	}
```

### 5.7.5 注册DisposableBean

Spring中不但提供了对应初始化方法的扩展入口,同样也提供了销毁方法的扩展入口,对于销毁方法的扩展,除了我们熟悉的配置destroy-method外,用户还可以注册后置处理器DestructionAwareBeanPostProcessor来同意处理bean的销毁方法

![BeanPostProcessor](C:\Users\10066610\Documents\Note\sring源码深度解析\imgs\BeanPostProcessor.png)

```java
	/**
	 * Add the given bean to the list of disposable beans in this factory,
	 * registering its DisposableBean interface and/or the given destroy method
	 * to be called on factory shutdown (if applicable). Only applies to singletons.
	 * @param beanName the name of the bean
	 * @param bean the bean instance
	 * @param mbd the bean definition for the bean
	 * @see RootBeanDefinition#isSingleton
	 * @see RootBeanDefinition#getDependsOn
	 * @see #registerDisposableBean
	 * @see #registerDependentBean
	 */
	protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
		AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
		if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
			if (mbd.isSingleton()) {
				// Register a DisposableBean implementation that performs all destruction
				// work for the given bean: DestructionAwareBeanPostProcessors,
				// DisposableBean interface, custom destroy method.
				registerDisposableBean(beanName,
						new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
			}
			else {
				// A bean with a custom scope...
				Scope scope = this.scopes.get(mbd.getScope());
				if (scope == null) {
					throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
				}
				scope.registerDestructionCallback(beanName,
						new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
			}
		}
	}
```

